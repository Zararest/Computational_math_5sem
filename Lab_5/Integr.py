import numpy as np


def trap(x, f, factor=1):
  res = 0
  h = x[1] - x[0]
  N = np.size(x)
  for i in range(0, N - factor, factor):
    res += ((f[i] + f[i+factor]) / 2) * h*factor
  return res  

def Symp(x, f):
  res = 0
  h = x[1] - x[0] 
  N = np.size(x)
  for i in range(0, N - 2, 2):
    res += ((f[i] + 4*f[i+1] + f[i+2]) / 6) * h*2
  return res

def main():
  x = np.array([0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1])
  f = np.array([0.0, 0.124670, 0.247234, 0.364902, 0.473112, 0.563209, 0.616193, 0.579699, 0.0])
  p = 2
  r = 2

  Ih  = trap(x, f)
  IhX2 = trap(x, f, r)

  # вычислим уточненное значение интеграла
  I = (r**p * Ih - IhX2)/(r**p - 1)
  Is = Symp(x, f)
  eps = abs(Is - I)

  print("Значение интеграла с обычным шагом сетки \nIh = ", Ih)
  print("Значение интеграла с удвоенным шагом сетки \nI2h = ", IhX2)
  print("Значение интеграла, уточненное методом Рунге \nI = ", I)
  print("Значение интеграла, посчитанное методом Симпсона \nIs = ", Is)
  print("Расхождение значений, полученных методом Симпсона и методом трапеций \neps = ", abs(Ih - Is))
  print("Расхождение значений, полученных методом Симпсона и методом Рунге \neps = ", eps)

  print('По полученным данным можно сделать вывод, что для подсчета более точного значения интеграла не обязательно строить метод более высокого порядка')
  print('Правило Рунге позволяет повысить точность после вычисления интеграла')

if __name__ == '__main__':
    main()